// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

#nullable enable

using System;
using System.Linq;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.DiaSymReader;
using Microsoft.CodeAnalysis.Debugging;
using Microsoft.CodeAnalysis.Emit;
using Microsoft.CodeAnalysis.ErrorReporting;
using Microsoft.CodeAnalysis.Text;
using Roslyn.Utilities;
using System.IO;
using System.Diagnostics;

namespace Microsoft.CodeAnalysis.EditAndContinue
{
    /// <summary>
    /// Encapsulates access to the last committed solution.
    /// We don't want to expose the solution directly since access to documents must be gated by out-of-sync checks.
    /// </summary>
    internal sealed class CommittedSolution
    {
        private readonly DebuggingSession _debuggingSession;

        private Solution _solution;

        /// <summary>
        /// Implements workaround for https://github.com/dotnet/project-system/issues/5457.
        /// 
        /// When debugging is started we capture the current solution snapshot.
        /// The documents in this snapshot might not match exactly to those that the compiler used to build the module 
        /// that's currently loaded into the debuggee. This is because there is no reliable synchronization between
        /// the (design-time) build and Roslyn workspace. Although Roslyn uses file-watchers to watch for changes in 
        /// the files on disk, the file-changed events raised by the build might arrive to Roslyn after the debugger
        /// has attached to the debuggee and EnC service captured the solution.
        /// 
        /// Ideally, the Project System would notify Roslyn at the end of each build what the content of the source
        /// files generated by various targets is. Roslyn would then apply these changes to the workspace and 
        /// the EnC service would capture a solution snapshot that includes these changes.
        /// 
        /// Since this notification is currently not available this map tracks document snapshots of documents whose
        /// content matches exactly to the the source file used to compile the binary currently loaded in the debuggee,
        /// 
        /// When EnC system analyzes document content it queries its in-sync state and adapts its behavior accordingly. 
        /// E.g. when EnC diagnostic analyzer analyzes a document for Rude Edits it ignores out-of-sync documents to
        /// avoid reporting false negatives. When the debugger attempts to apply changes on "continue" the EnC service
        /// blocks the operation if there are any out-of-sync documents present.
        /// 
        /// Whenever we receive the file-watcher event ... TODO
        /// </summary>
        private readonly Dictionary<DocumentId, bool> _documentMatchesDebuggee;

        private readonly object _guard = new object();

        public CommittedSolution(DebuggingSession debuggingSession, Solution solution)
        {
            _solution = solution;
            _debuggingSession = debuggingSession;
            _documentMatchesDebuggee = new Dictionary<DocumentId, bool>();
        }

        // test only
        internal void Test_SetDocumentSyncStatus(DocumentId documentId, bool inSync)
        {
            lock (_guard)
            {
                _documentMatchesDebuggee[documentId] = inSync;
            }
        }

        public Project? GetProject(ProjectId id)
            => _solution.GetProject(id);

        public ImmutableArray<DocumentId> GetDocumentIdsWithFilePath(string path)
            => _solution.GetDocumentIdsWithFilePath(path);

        public bool ContainsDocument(DocumentId documentId)
            => _solution.ContainsDocument(documentId);

        /// <summary>
        /// Returns a document snapshot for given <see cref="DocumentId"/> whose content exactly matches
        /// the source file used to compile the binary currently loaded in the debuggee. Returns null
        /// if it fails to find a document snapshot whose content hash maches the one recorded in the PDB.
        /// 
        /// The result is cached and the next lookup uses the cached value, including failures.
        /// </summary>
        public Task<Document?> GetDocumentAsync(DocumentId documentId, CancellationToken cancellationToken)
            => GetDocumentMatchingDebuggeeAsync(documentId, ignoreCachedFailure: false, cancellationToken);

        /// <summary>
        /// Captures the content of a file that is about to be overwritten by saving an open document,
        /// if the document is currently out-of-sync and the content of the file matches the PDB.
        /// If we didn't capture the content before the save we might never be able to find a document
        /// snapshot that matches the PDB.
        /// </summary>
        public Task OnSourceFileUpdatedAsync(DocumentId documentId, CancellationToken cancellationToken)
            => GetDocumentMatchingDebuggeeAsync(documentId, ignoreCachedFailure: true, cancellationToken);

        private async Task<Document?> GetDocumentMatchingDebuggeeAsync(DocumentId documentId, bool ignoreCachedFailure, CancellationToken cancellationToken)
        {
            Document? document;

            lock (_guard)
            {
                document = _solution.GetDocument(documentId);
                if (document == null)
                {
                    return null;
                }

                if (document.FilePath == null)
                {
                    return document;
                }

                if (_documentMatchesDebuggee.TryGetValue(documentId, out var documentMatchesDebuggee) &&
                    (documentMatchesDebuggee || !ignoreCachedFailure))
                {
                    return document;
                }
            }

            var matchingSourceText = await TryGetPdbMatchingSourceTextAsync(document.FilePath, document.Project.Id, cancellationToken).ConfigureAwait(false);

            var matchingDocument = (matchingSourceText == null) ? null :
                                   document.TryGetText(out var sourceText) && sourceText.ContentEquals(matchingSourceText) ? document :
                                   document.WithText(matchingSourceText);

            lock (_guard)
            {
                if (_documentMatchesDebuggee.TryGetValue(documentId, out var documentMatchesDebuggee) && documentMatchesDebuggee)
                {
                    return document;
                }

                _documentMatchesDebuggee[documentId] = matchingDocument != null;

                if (matchingDocument != null)
                {
                    _solution = matchingDocument.Project.Solution;
                }
            }

            return matchingDocument;
        }

        public void OnDocumentChangedAsync(DocumentId documentId)
        {
            lock (_guard)
            {
                // Invalidate cached failure - next time the document is requested we will check the content of the file again:
                if (_documentMatchesDebuggee.TryGetValue(documentId, out var documentMatchesDebuggee) && !documentMatchesDebuggee)
                {
                    _documentMatchesDebuggee.Remove(documentId);
                }
            }
        }

        public void CommitSolution(Solution solution, ImmutableArray<Document> updatedDocuments)
        {
            lock (_guard)
            {
                // Changes in the updated documents has just been applied to the debuggee process.
                // Therefore, these documents now match exactly the state of the debuggee.
                foreach (var document in updatedDocuments)
                {
                    _documentMatchesDebuggee[document.Id] = true;
                    Debug.Assert(document.Project.Solution == solution);
                }

                _solution = solution;
            }
        }

        private async Task<SourceText?> TryGetPdbMatchingSourceTextAsync(string sourceFilePath, ProjectId projectId, CancellationToken cancellationToken)
        {
            var (symChecksum, algorithm) = await TryReadSourceFileChecksumFromPdb(sourceFilePath, projectId, cancellationToken).ConfigureAwait(false);

            try
            {
                using var fileStream = new FileStream(sourceFilePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete);
                var sourceText = SourceText.From(fileStream, checksumAlgorithm: algorithm);
                return sourceText.GetChecksum().SequenceEqual(symChecksum) ? sourceText : null;
            }
            catch (Exception e)
            {
                EditAndContinueWorkspaceService.Log.Write("Error calculating checksum for source file '{0}': '{1}'", sourceFilePath, e.Message);
                return null;
            }
        }

#if F
        /// <summary>
        /// Invoked when a document is updated in a workspace that potentially affects the initial snapshot.
        /// This may occur when a file-system watcher detects a change in a file on disk and updates the workspace.
        /// </summary>
        internal async Task OnPossibleDocumentBaselineUpdatedAsync(Document newDocument, CancellationToken cancellationToken)
        {
            try
            {
                Contract.ThrowIfNull(newDocument.FilePath);

                AsyncLazy<bool> lazyInSync;

                lock (_documentSyncStatusGuard)
                {
                    // Once document is validated to be in-sync, it stays in-sync until the end of the debugging session.
                    if (_documentSyncStatus.TryGetValue(newDocument.Id, out lazyInSync) &&
                        lazyInSync.TryGetValue(out var result) && result)
                    {
                        return;
                    }
                }

                var inSync = await lazyInSync.GetValueAsync(cancellationToken).ConfigureAwait(false);
                if (inSync)
                {
                    // Nothing to do for documents that are already in-sync.
                    return;
                }

                var matches = await SourceMatchesInitialPdbAsync(newDocument, cancellationToken).ConfigureAwait(false);
                if (!matches)
                {
                    // Ignore updates that do not match the checksum in the initial PDB
                    EditAndContinueWorkspaceService.Log.Write("Source file '{0}' updated from disk but does not match PDB", newDocument.FilePath);
                    return;
                }

                // The EnC service never reads a content from the last committed solution of an out-of-sync document.
                // Therefore it is safe to replace its text without invalidating any analysis results here.

                UpdateDocumentText(newDocument.Id, await newDocument.GetTextAsync(cancellationToken).ConfigureAwait(false));

                // Once the document in the last committed solution is updated, we can declare it in-sync and allow EnC service to access its content.
                lock (_documentSyncStatusGuard)
                {
                    if (_documentSyncStatus.TryGetValue(newDocument.Id, out lazyInSync) &&
                        lazyInSync.TryGetValue(out var result) && result)
                    {
                        return;
                    }

                    _documentSyncStatus[newDocument.Id] = new AsyncLazy<bool>(true);
                }

                EditAndContinueWorkspaceService.Log.Write("Source file '{0}' updated from disk", newDocument.FilePath);
            }
            catch (Exception e) when (FatalError.ReportWithoutCrashUnlessCanceled(e))
            {
                // no-op
            }
        }
#endif
        private async Task<(ImmutableArray<byte> Checksum, SourceHashAlgorithm Algorithm)> TryReadSourceFileChecksumFromPdb(string sourceFilePath, ProjectId projectId, CancellationToken cancellationToken)
        {
            try
            {
                var (mvid, mvidError) = await _debuggingSession.GetProjectModuleIdAsync(projectId, cancellationToken).ConfigureAwait(false);
                if (mvid == Guid.Empty)
                {
                    EditAndContinueWorkspaceService.Log.Write("Source '{0}' doesn't match PDB: can't read MVID ('{1}')", sourceFilePath, mvidError);
                    return default;
                }

                var moduleInfo = _debuggingSession.DebugeeModuleMetadataProvider.TryGetBaselineModuleInfo(mvid);
                if (moduleInfo == null)
                {
                    EditAndContinueWorkspaceService.Log.Write("Source '{0}' doesn't match PDB: can't get baseline SymReader", sourceFilePath);
                    return default;
                }

                cancellationToken.ThrowIfCancellationRequested();

                try
                {
                    var symDocument = moduleInfo.SymReader.GetDocument(sourceFilePath);
                    if (symDocument == null)
                    {
                        EditAndContinueWorkspaceService.Log.Write("Source '{0}' doesn't match PDB: no SymDocument", sourceFilePath);
                        return default;
                    }

                    var symAlgorithm = SourceHashAlgorithms.GetSourceHashAlgorithm(symDocument.GetHashAlgorithm());
                    if (symAlgorithm == SourceHashAlgorithm.None)
                    {
                        // unknown algorithm:
                        EditAndContinueWorkspaceService.Log.Write("Source '{0}' doesn't match PDB: unknown checksum alg", sourceFilePath);
                        return default;
                    }

                    var symChecksum = symDocument.GetChecksum().ToImmutableArray();

                    return (symChecksum, symAlgorithm);
                }
                catch (Exception e)
                {
                    EditAndContinueWorkspaceService.Log.Write("Source '{0}' doesn't match PDB: error reading symbols: {1}", sourceFilePath, e.Message);
                    return default;
                }
            }
            catch (Exception e) when (FatalError.ReportWithoutCrashUnlessCanceled(e))
            {
                return default;
            }
        }
    }
}
